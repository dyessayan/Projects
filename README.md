Description of Representations Used
The code developed for this project aimed to find the shortest and longest path/sequence to connect all the dots in the Traveling Salesman problem (TSP). Three optimization strategies were used: Random Search, Hill Climbing, and Genetic Algorithm. 
The Random Search is the most straightforward algorithm. It generates a random path and computes the length for a given amount of iterations. The shortest and longest path found is stored as it keeps generating random paths.
The Hill Climbing Algorithm starts with a random solution and then starts to make adjustments to its search. This algorithm generates "neighboring solutions," which are just small incremental changes to its current solution. This helps maximize or minimize the function to find the shortest and longest path.
The Genetic Algorithm (GA) uses natural selection and genetic evolution to generate paths. The GA Algorithm evolves populations of solutions over multiple generations using crossover, mutation, and other methods iteratively. This allows the algorithm to find better solutions.  

Description of Random Search Algorithm
This algorithm conducts a random search over a space of paths. In each of the `TEST_PATHS` iterations, it generates a random path, evaluates its length, and checks if it's better than the best found so far. The best path and its length are continuously logged and updated. After all iterations, the best path found is presented.
Description of the Random Mutation Hill Climber Algorithm
The algorithm begins with a random starting path. This path is then subjected to iterative improvements. The main loop attempts to find shorter paths by making pairwise swaps of elements within the current path. After each swap, the new path's length is evaluated. If a shorter path is found through a swap, it becomes the new current path. During the search, results of each iteration, such as the best path found and its corresponding length, can be saved to the CSV file. If no better path is identified after all possible pairwise swaps, the algorithm concludes it has reached a local optimum and terminates the search.

Description of the Evolutionary Algorithm, including the variation and selection methods used
	In the EA, a population of random paths was initialized. The fitness of each individual path in the population is calculated for each generation. The best solution for the current population is identified and logged. A new population for the next generation is generated using various methods, including tournament selection, elitism, cut-and-crossfill, and swap and segment shuffle mutation methods. The process is repeated with this new population using this generational algorithm where 500 population members produced 500 offspring and were entirely replaced by their offspring. A termination condition was not introduced except for reaching the predefined number of generations.

Analysis of the performance of the Algorithms
The Random Search Algorithm performed as expected. The algorithm's run-time was far shorter compared to the Hill-Climber and Genetic Algorithm; however, the optimal values found were far less. 
The Hill-climbing algorithm performed exceptionally well. It found optimal solutions for the TSP problem within 20,000 iterations and drastically outperformed the Genetic Algorithm in the early stages of optimization. The algorithm did terminate quite early and was limited by its pairwise swaps, which led to fewer possible solutions.
The Genetic Algorithm's performance can be influenced by numerous variables. A larger tournament size might have improved selection pressure versus encouraging diversity. Distance between solutions wasn't analyzed; however, some measure this to regulate population diversity. Given time, considering parallelization would be beneficial, especially since tournament selection parallelizes well, lacking the population data needs of Roulette wheel selection. It's also effective in steady-state algorithms.
The top 50 members remained consistent across generations due to elitism, vital for the genetic algorithm's monotonicity and is sometimes associated with convergence proofs. A 'Cut-and-crossfill' one-point crossover was employed. Alternatives like the partially mapped or cycle crossover might have been considered. The chosen recombination likely preserves building blocks. Two mutations, Swap and Segment shuffle, were applied. Swap interchanged two random genes, potentially far apart on the chromosome. Segment shuffle, however, acted on a confined chromosome segment. The mutation probability reduced from 0.8 to 0.01 over time, maintaining a consistent ratio of 0.75 for swap and 0.25 for Segment shuffle. Recombination probability decreased from 0.95 to 0.6. Post-tournament selection, if two individuals weren't chosen for recombination, they'd potentially mutate and transfer to the next generation.
While some opt to auto-adjust genetic algorithm parameters, this introduces programming complexity. It could involve making mutation or recombination probabilities an attribute of an "individual" class, subject to mutation themselves.
The Genetic Algorithm did not surpass the optimal values found by the Hill-Climber Algorithm, but this was primarily due to constraints on the run time. Given a more extended period of time to run the algorithm, it was trending towards overtaking the Hill-Climber Algorithm.

